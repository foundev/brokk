package io.github.jbellis.brokk.analyzer.builder

import io.github.jbellis.brokk.analyzer.builder.IncrementalUtils.*
import io.github.jbellis.brokk.analyzer.builder.passes.base.{IdempotentContainsEdgePass, IdempotentFileCreationPass, IdempotentNamespaceCreator}
import io.joern.x2cpg.X2CpgConfig
import io.joern.x2cpg.passes.base.*
import io.joern.x2cpg.passes.callgraph.*
import io.joern.x2cpg.passes.frontend.MetaDataPass
import io.joern.x2cpg.passes.typerelations.*
import io.shiftleft.codepropertygraph.generated.Cpg
import io.shiftleft.passes.CpgPassBase
import io.shiftleft.semanticcpg.language.*

import java.io.IOException
import java.nio.file.Paths
import scala.util.{Try, Using}

/**
 * A trait to be implemented by a language-specific incremental CPG builder.
 *
 * @tparam R the language's configuration object.
 */
trait CpgBuilder[R <: X2CpgConfig[R]] {

  /**
   * The user-friendly string for the target language.
   */
  protected val language: String

  /**
   * Given an initialised CPG and a configuration object, incrementally build the existing CPG with the changed files 
   * at the path determined by the configuration object.
   *
   * @param cpg    the CPG to be built or updated.
   * @param config the language-specific configuration object containing the input path of source files to re-build
   *               from.
   * @return the same CPG reference as given. 
   */
  def build(cpg: Cpg, config: R): Cpg = {
    if (cpg.metaData.nonEmpty) {
      val fileChanges = IncrementalUtils.determineChangedFiles(cpg, Paths.get(config.inputPath))
      cpg.removeStaleFiles(fileChanges)
        .buildAddedAsts(fileChanges, buildDir => runPasses(cpg, config.withInputPath(buildDir.toString)))
    } else {
      runPasses(cpg, config)
    }
  }

  protected def runPasses(cpg: Cpg, config: R): Cpg = {
    Using.resource(createAst(cpg, config).getOrElse {
      throw new IOException(s"Failed to create $language CPG")
    }) { cpg =>
      applyPasses(cpg).getOrElse {
        throw new IOException(s"Failed to apply post-processing on $language CPG")
      }
    }
  }

  /**
   * Given a CPG will create the meta-data node if none exists. If one exists, we assume that the given input path points
   * to a temporary directory of files that require rebuilding for some incremental update.
   *
   * @param cpg       the CPG.
   * @param language  the target language.
   * @param inputPath the input path.
   * @return the given CPG.
   */
  protected def createOrUpdateMetaData(cpg: Cpg, language: String, inputPath: String): Cpg = {
    if cpg.metaData.isEmpty then new MetaDataPass(cpg, language, inputPath).createAndApply()
    cpg
  }

  /**
   * Runs the AST creator for the specific frontend, and any other frontend-specific passes before base overlays are
   * applied.
   *
   * @param cpg    the CPG.
   * @param config the frontend config.
   * @return this CPG if successful, an exception if otherwise.
   */
  protected def createAst(cpg: Cpg, config: R): Try[Cpg]

  /**
   * Runs the necessary "base" passes over an existing or new CPG generated by Joern. Think of this as fine-tuned
   * "base passes" that turn an AST to a CPG.
   *
   * @param cpg some updated or new CPG to apply passes to. This CPG will be mutated.
   * @return this CPG if successful, an exception if otherwise.
   */
  protected def applyPasses(cpg: Cpg): Try[Cpg] = Try {
    // These are separated as we may want to insert our own custom, framework-specific passes
    // in between these at some point in the future. For now, these resemble the default Joern
    // pass ordering and strategy minus CFG.
    (basePasses(cpg) ++ typeRelationsPasses(cpg) ++ callGraphPasses(cpg)).foreach(_.createAndApply())
    cpg
  }


  protected def basePasses(cpg: Cpg): Iterator[CpgPassBase] = {
    Iterator(
      new IdempotentFileCreationPass(cpg),
      new IdempotentNamespaceCreator(cpg),
      new MethodStubCreator(cpg),
      new ParameterIndexCompatPass(cpg),
      new MethodDecoratorPass(cpg),
      new AstLinkerPass(cpg),
      new IdempotentContainsEdgePass(cpg),
      new TypeRefPass(cpg),
      new TypeEvalPass(cpg),
    )
  }

  protected def typeRelationsPasses(cpg: Cpg): Iterator[CpgPassBase] = {
    Iterator(
      new TypeHierarchyPass(cpg),
      new AliasLinkerPass(cpg),
      new FieldAccessLinkerPass(cpg),
    )
  }

  protected def callGraphPasses(cpg: Cpg): Iterator[CpgPassBase] = {
    Iterator(
      new MethodRefLinker(cpg),
      new StaticCallLinker(cpg),
      new DynamicCallLinker(cpg)
    )
  }

}
